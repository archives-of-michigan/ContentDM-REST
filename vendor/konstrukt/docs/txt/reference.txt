Konstrukt Reference
===================

{TOC}

This document contains a description of the features of Konstrukt. For a more hands-on introduction, you should start out with [getting started](getting-started-part1.html).

There is also an autogenerated [api-reference](apidocs.html), which contains all classes, interfaces and methods in the library.

If you find any errors - even if it's just a spelling mistake, or a dodgy phrasing - don't hesitate to tell about it.

Troels Knak-Nielsen, January 2009, troelskn@gmail.com

Component essentials
--------------------

A component is a class that extends from `k_Component`. Its purpose is to handle a request or delegate control to another component, that can handle it. This is much similar to how the Apache web server is structured. The way a component is addressed is through the URL path. Each path segment is mapped to a component. The special thing about Konstrukt in this respect, is that the exact mapping is determined at runtime. Each component is fully responsible for choosing the next component in the chain. This is a very powerful concept, but can also be slightly hard to comprehend at first. As a newcomer you may therefore find the [dispatch logging](debugging) useful.

###Dispatch life-cycle

A component is instantiated as an object before use. To allow for maximum flexibility in implementation, the constructor is not used for passing essential dependencies. These are instead passed immediately after creation through setters. Of these dependencies, the most important is the context, which will usually be another component instance.

A a developer you have great control over the creation of components. You can read more about this in the section on [component creation](#component-creation).

###dispatch, map, forward

Once the component is instantiated, it is given control by the context calling the `dispatch()` method. The purpose of this method is to inspect the url subspace and either determine that it is the final handler in the chain, or forward control to another component, which will go through the same process. These choices corresponds to the methods `forward()` and `execute()`. To make the choice, the method `map()` is used. As a developer, you will often override `map()` to implement url mapping logic.

###execute, GET, POST

The `execute()` method is the first method invoked for the handling component. It is unusual to override this in concrete components, although there are cases for it. Since execute is invoked for any kind of HTTP-method, it is a good place to load model components that are identified by the url of the component. The default implementation of `execute()` inspects the HTTP-method and delegates control to one of `GET()`, `POST()`, `HEAD()`, `PUT()` or `DELETE()`. In most web applications, you will probably just concern your self with the first two, since these are the only one widely supported by browsers. Luckily they are also the most important.

###Renderers


The `GET()` and `POST()` methods can be overridden, but it's now recommended that you don't override `GET()`. The default implementation of `GET()` will negotiate the content-type, and finally delegate control to a render method. So for most applications, you would implement `renderHtml()`. You can implement multiple renderers, and the negotiation will pick the best candidate. The naming of renderers corresponds to their content-type per the following chart:

content-type             | short name | render method
------------------------ | ---------- | -------------
text/html                |    html    | renderHtml
text/html+edit           |    edit    | renderEdit
text/xml                 |    xml     | renderXml
text/plain               |    text    | renderText
text/csv                 |    csv     | renderCsv
text/x-vcard             |    vcard   | renderVcard
application/atom+xml     |    atom    | renderAtom
application/calendar+xml |    xcal    | renderXCal
application/rdf+xml      |    rdf     | renderRdf
application/json         |    json    | renderJson
application/pdf          |    pdf     | renderPdf
image/svg+xml            |    svg     | renderSvg

If a component supports multiple renderers, you can refer to a specific representation by suffixing the url with a semicolon and the short-name. Eg. `/foo/bar;csv` is the CSV representation of `/foo/bar`. When specifying the content-type this way, the Accept header is disregarded.

The type `text/html+edit` is meant for a html form to edit the resource.

If you need a content-type that isn't listed above, you can add it to the `$renderers` property in your component. The format is:

..php
$this->renderers['test/html;html'] = 'renderHtml';

The return type of a renderer should either be a string (Which is expected to be a HTML fragment) or the method should throw a response. Remember to specify the content-type, if you're throwing a response to a non-HTML content-type.

HTTP input
----------

A component can access the various inputs that comes from a http-request. These are obtained through the `$context` object, rather than through a global place, which makes components very encapsulated and - among other things - more testable.

Note that all these properties are accessed through methods, not as fields. So you would refer to `$this->name()` rather than `$this->name`

###name, subtype, subspace

Initially the most important input is probably the `name`. This returns the part of the url that this component belongs to. For the last component of the url `/foo/bar/quux`, the name would be `quux`. This property is often used as a primary key for identifying the underlying resource.

The `subtype` property is the part of a path-segment that comes after the name, delimited by a semi-colon. It's used internally to identify the content-type. As a developer you'll probably not need to access this very often.

The `subspace` property contains the remaining part of the path, for a component that isn't the last in the dispatch chain. For example, given the component identified as `bar` in the url `/foo/bar/quux`, the subspace would be `quux`. This property is also rarely used directly.

###query, body

In addition to the url/path, there are two important input sources; The query-string and the request body. In plain PHP, these are available through `$_GET` and `$_POST` respectively, but in Konstrukt they are accessed through `query()` and `body()`. This naming is more precise, in that query-string parameters aren't just for GET requests, and a request body can come with other kinds of requests than a POST.

You can call the accessors without any arguments and get a hashmap back, or you can provide a name, and just get the value for that field. If the key isn't set, you will get back `null`, rather than a warning.

..php
  $this->query(); // array('foo' => 'bar')
  $this->query('foo'); // 'bar'

You can also pass a default value that will be returned if the specified key doesn't exist.

..php
  // /baz?grault=waldo
  $this->query('foo', 'bar'); // 'bar'

###Querystring namespace

Because the querystring is shared amongst every component, you can sometimes run into problems when you need to pass parameters to multiple components (Not exactly a common requirement, but it can happen). Components can use a namespace to protect the querystring in these cases.
It's the context that specifies a namespace for its subcomponents, and it works completely transparent to the subcomponent. To create a component with a namespace, your `map()` method should return an array instead of a string, where the first element is the namespace and the second is the classname.

###Session

Sessions are a very powerful feature for maintaining state in a web application. Unfortunately it's often overused. While there are cases where it's the best pick, you should generally try to use some other means of maintaining state, if at all possible. That said, Konstrukt provides access to PHPs session mechanism, through a wrapper.

Each component has a method `session()` that can be called in two ways. Either you provide an argument (Which should be a string), and you'll get the value of a session variable by that name back (or null, if it's not defined). Alternatively you can call it without any arguments, in which case you'll an object back of the type `k_adapter_SessionAccess`. It has methods for getting/setting session variables and other session-related functions.

Note that you don't need to worry about calling `session_start()`, since this is done automatically by the wrapper.

###Cookies

A cookie is a mixed client/server side way of maintaining state. It has a number of limitations which makes it a less popular choice, but it can still be useful in certain cases. You can access cookies through a wrapper in Konstrukt.

The cookie wrapper works just as the session wrapper. Each component has a method `cookie()` that can be called with a parameter to retrieve the value of a cookie by that name, or without any arguments to get an object back of the type `k_adapter_CookieAccess`.

###File uploads

In PHP files uploaded with a form are accessible through `$_FILES`. Inside a component, you can access the same information through the method `file()`. You can either pass a parameter to get back a specific file or call it without any arguments to get a hashmap of all files. A file is wrapped in an object of the type `k_adapter_UploadedFile`, which helps to abstract direct access to the filesystem away. As a side effect it also has a simpler interface than PHPs native handling of file uploads. To save an uploaded file, just call `writeTo($path_destination)` with the destination as argument.

Note that you need to go through the [regular hoops to get file uploads working](http://www.php.net/features.file-upload.post-method.php). Most importantly you need to set the `enctype="multipart/form-data"` property on your form tag.

Url generation
--------------

All components are tightly coupled to a url. Components can parse (dispatch) urls, and they can also generate urls. To make your application as flexible as possible, it is recommended that you generate internal urls, using the `url()` method, rather than hardcoding them as strings. From within a component, you can call `url()` without any parameters to get a url pointing to the current component. As the first argument, you can pass a subspace, and as the second argument, you can pass a hash of query-string parameters. Eg.:

..php
   $this->url('foo', array('bar' => 42)); // -> /url/for/this/component/foo?bar=42

Generating urls this way, makes it easy to move components around without having to make any changes to the view.

Note that the first argument isn't automatically encoded. You can optionally pass an array of strings instead. These are then encoded and joined with a path-separator (A slash). Eg.:

..php
   $this->url(array('foo', 'quux'), array('bar' => 42)); // -> /url/for/this/component/foo/quux?bar=42

..note
  Apache has a [security feature](http://httpd.apache.org/docs/2.2/mod/core.html#allowencodedslashes) that disallows url path segments to contain an encoded slash. Thus, you should avoid names that contains slashes. In general, it is a good idea to stick to `a-z0-9_-` for url names.

###Urlstate parameters

If a component needs to maintain view-related state, you have a limited set of options. In essence, the choice is between propagating state over urls (client side state) or using a server side mechanism (eg. sessions). Cookies are also a solution, but it has most of the problems associated with session state, and even some of its own. Client side state is often the superior choice, but it is tedious to do by hand. Konstrukt has therefore a mechanism builtin to support this. Viewstate can be propagated as querystring parameters, using the `urlstate` property of a component. Properties that are set on the urlstate will be automatically set on any urls for the component, unless explicitly overridden. A typical usecase is for searches and other data-views.

Urlstate parameters are specified, along with their initial value, by implementing the `url_init` in your component. For example, to the following specifies a single parameter "foo". If no input is present for it, it has the value "bar":

..php
class MyStatefulComponent extends k_Component {
  protected $url_init = array('foo' => "bar");
}

If a urlstate parameter is passed on the querystring, it will automatically override the urlstate containers value. Eg. for a request with the query-string `?foo=quux`, the following would yield "quux":

..php
  $this->url_state->get('foo'); // -> "quux"

Shared objects
--------------

A few objects are shared amongst all components.

###Identity

The identity object is an object represeting the current user. Every component can access the identity by calling the access `identity()`. The default implementation is `k_Anonymous`.

The identity is loaded from an `k_DefaultIdentityLoader`, that can be configured with the [bootstrap](#bootstrap). An identity-loader is a simple factory, that gets passed the top-level context, and is expected to return an instance of `k_Identity`. The usual use case is to load a user-object from the database or an authentication system.

###Document

The document is an instance of `k_Document`, and contains values that are global to the HTML document, such as title, CSS includes etc. A component can access the document via the `document()` method.

The default document has accessors for setting the title, adding external javascript and Css files to `<head>`, and adding javascript code to run on page load. This is a fairly limited number of properties. If you need more, you could subclass `k_Document` and set your own implementation in the [bootstrap](#bootstrap). It is recommended to keep such properties as specific as possible, to prevent that the object becomes a dumping ground for global variables.

Abnormal responses
------------------

By default, components are expected to return a string of html, that can be a full or partial html document. This is the primary format of web applications, and therefore gets a special treatment over other formats. Sometimes though, you don't want the output to be embedded in the normal rendering mechanism or you need more fine grained control over the http response. This could be the case with alternative content-types, that shouldn't go in to the normal rendering chain, or it could be a redirect or an error code of some kind.

These are collectively called abnormal responses, because they circumvent the normal rendering chain. To do this, abnormal responses are implemented in Konstrukt as exceptions. To emit an abnormal response, you throw it instead of returning a string. The dispatcher will then catch it and use it for output.

There are two kinds of abnormal responses, for different levels of abstraction/control.

###Http response

A httpresponse is the least abstract kind of abnormal response. It gives you full control over the http-level output sent back to the client, including headers and status codes. You should use this for serving non-html content-types.

In addition to the generic `k_Httpresponse`, there are three specialised variations that should be used for redirects:

`k_MovedPermanently`
: Use this if the URL has changed (Eg. a page has been renamed).

`k_SeeOther`
: Use this type of redirect specifically for redirecting after POST.

`k_TemporaryRedirect`
: Use this type of redirect if the destination changes from request to request, or if you want the client to keep using the requested URI in the future.

###Meta response

A metaresponse is a more abstract form of response. While you could just use a httpresponse, you should try to use these for, if possible, since they make your application more flexible. A metaresponse is transformed into a concrete httpresponse by the dispatcher. The primary benefit of using a metaresponse over a httpresponse, is that it gives you control over rendering of various error-pages. For example, rather than constructing a httpresponse with status 404, you should use the metaresponse NotFound. This makes it possible to have a customised page for all "not found" responses.

The currently supported metaresponses are:

`k_Forbidden`
: Raise this if the user doesn't have access to the requested resource.

`k_PageNotFound`
: Raise this if the requested resource couldn't be found.

`k_MethodNotAllowed`
: Raise this if resource doesn't support the requested HTTP method.

`k_NotImplemented`
: This is roughly the HTTP equivalent to a "todo"

A metaresponse is associated with a componentname. For example, `k_Forbidden` resolves to `k_DefaultForbiddenComponent`. To get a customised handler for these types of responses, you can let your [component creator](#component-creation) return a custom component instead of the defaults.

Templates
---------

Components usually return a html string. How they are rendered is largely left up to the developer. A common practise is to use a template engine though. Konstrukt includes a very simple template engine, which just wraps a regular PHP script in an output buffer. This strategy of using PHP as a template language works fine as long as you have some control over the provider of templates. It does have some drawbacks though, so some people might prefer to use a real template engine. Konstrukt comes with an example of how to use the Smarty template engine, but it should be equally simple to use any other template engine.

###PHP-templates

To use the default template engine, you should instantiate and object of `k_Template`. The interface is simple; You pass a path to a PHP template. Calling `render()` will include the file inside a buffer and return the output. The calling component must pass a reference to itself to the template. This is to allow the template to access variables it might need. You should add methods on your component to provide the variables that your template might need.

The template binds a few global functions to make it easier for the template to call certain common features with a simple syntax. These are:

`e()`
: This function escapes HTML special-characters in input and prints it in-place. Use this for embedding values in html-documents.

`__()`, `t()`
: These are both aliases for `$context->__()`. You can use this hook for implementing i18n support in your application. Note that there is no default implementation for `__()`, so you need to explicitly implement this in your components, if you wish to support the feature.

`url()`
: This is bound to `$context->url()`.

Component creation
------------------

In the [dispatch process](#dispatch-map-forward), a component may delegate control to a sub component. In doing so, the new component must be instantiated first. This task is handled by a discrete object, called a _component creator_. This can be configured in the [bootstrap](#bootstrap), which allows you to replace this without having to mingle with the internals of the library.

###DI containers

The intended use for a component creator, is to allow the use of a [dependency injection container](http://c2.com/cgi/wiki?DependencyInjection) for creation of components. The base class for components (`k_Component`) doesn't have a constructor defined, which allows you free control over this for your components. This is practical because DI containers often use the constructor to provide dependencies. By default, Konstrukt doesn't provide a DI container, but it comes with bindings for [Phemto](https://phemto.svn.sourceforge.net/svnroot/phemto/trunk), and it's very simple to write adapters for other containers.

###createComponent

Most sub components are created from the dispatch process, but sometimes you need to create components manually. To do this, you can invoke the `createComponent()` method on a component, which would create a new sub component. The method takes an optional namespace, which is the [namespace used for querystring parameters](#querystring-namespace).

Encoding
--------

Until version 6 becomes current, PHP is stuck with a primitive view of string data, where strings are treated as bytestreams. Many libraries, extensions and even core functionality in PHP, assumes that strings are single-byte streams. This means that each byte is interpreted as a character, the consequence being that only 256 different characters can be represented. Furthermore, the default charset assumed is ISO-8859-1 (also known as latin1). As long as we only want to represent western European texts this suffices, but in our multi cultural world, this is inadequate.

###How to use utf-8

Even if your main audience is English speaking, your users may still have foreign names, that can't be written with the limited charset of latin1. Currently, the best solution is therefore to use UTF-8 as encoding throughout your application. This strategy does have its pitfalls, but so does using latin1. It is important to get these things right from the beginning, since it's a thing that is very hard to change later.

Konstrukt defaults to speak UTF-8 at the HTTP-level. If you use a database, you should make sure that data is stored as UTF-8 or another Unicode capable encoding, and you should also make sure that the connection between PHP and database is set to UTF-8 (This only apply to some databases, such as MySql). Also, make sure that any files - especially template files - are saved as UTF-8 (Without BOM). This covers the most common problems with UTF-8.

There is a good overview of the core PHP functions, that needs special treatment to work with UTF-8 at [http://www.phpwact.org/php/i18n/utf-8](http://www.phpwact.org/php/i18n/utf-8).

###Plan b (legacy applications)

Some times you don't have the luxury of going with UTF-8. If you're interfacing with a legacy application or you want to use third-party libraries that assume single-byte strings, you will have to use a single-byte internal encoding. Konstrukt has a configurable strategy for dealing with charsets, which enables you to switch to one of two alternate configurations, that both have a single-byte internal encoding. The first is a plain single-byte/latin1 strategy, where pages are served with `charset=iso-8859-1`. This is basically the same modus that plain PHP works in. The other strategy encodes output to UTF-8 and decodes it back to latin1. That way the application works with latin1 on the inside (in the scope of PHP), while presenting a UTF-8 facade outwards. The benefit of this approach is that it makes it easier for other applications to interact with yours. For example, [XmlHttpRequest](http://en.wikipedia.org/wiki/XMLHttpRequest) (javascript) defaults to talk UTF-8. It also avoids the problem of the [ISO-8859-1 vs. CP-1252 confusion](http://en.wikipedia.org/wiki/ISO_8859-1#ISO-8859-1_and_Windows-1252_confusion). If you're building a new frontend for a legacy backend, this may be a good compromise.

To change the charset strategy, assign a `k_charset_CharsetStrategy` in the [bootstrap](#bootstrap), using `setCharsetStrategy()`. Konstrukt comes with the following three options:

`k_charset_Utf8CharsetStrategy`
: The default choice. Assumes that all strings are UTF-8 encoded.

`k_charset_Latin1CharsetStrategy`
: Legacy compatibility. Assumes that all strings are ISO-8859-1 encoded.

`k_charset_FauxUtf8CharsetStrategy`
: Like Latin1, but presents an external facade of UTF-8. Assumes that all internal strings are ISO-8859-1 encoded.

Environment/setup
-----------------

Konstrukt is fairly liberal about how files are organised. The library must of course be included in your application (Eg. `lib/konstrukt.inc.php`).

To make it easier to get started with Konstrukt, a "starterpack" is included, that gives you a default directory layout and configuration. If you're starting a new project, it's probably a good idea to follow this standard. However, these are just suggestions and it shouldn't be a problem to divert from it.

Currently, Konstrukt comes with two different variations of the starterpack. They are quite similar, where one is a subset of the other. `starterpack_light` doesn't have any external dependencies, except for Konstrukt. It doesn't feature a DI container and it uses the simple PHP-style templates that is provided through `k_Template`. The other option - `starterpack_default` adds Phemto as a DI container and the Smarty template engine. It also gives you a place to put test cases, using SimpleTest. This is the default recommended setup; If you don't want to use one of the components, you may find it easier to remove from the default package, rather than adding to the light package.

###File layout

The file layout of the starterpacks are as follows:

    config/               -- Global settings and other static configuration files
    lib/                  -- Application specific PHP-code
    lib/components/       -- Subclasses of k_Component.
    log/                  -- Folder for various logfiles
    log/development.log   -- The application debug log.
    log/error.log         -- PHP error-log.
    templates/            -- Template files
    templates_c/          -- Compiled Smarty template files. This is specific `starterpack_default`
    test/                 -- Automated tests. This is specific `starterpack_default`
    test/unit/            -- Unit tests.
    test/functional/      -- Functional tests (Eg. tests of individual components).
    var/                  -- Place for various datafiles, such as sqlite database etc.
    www/                  -- The directory that should be mounted as web root. Contains static content, such as Javascript files.
    www/.htaccess         -- Contains configuration for Apache.

###Static content

The `www` folder should be mounted as the `DocumentRoot` of your website. `mod_rewrite` is used to delegate control to Konstrukt. You can place static content in this folder, such as Javascript and CSS files or other static content. Apache will then serve these directly, without invoking PHP.

This setup assumes that `www` is mounted as the web root. If you want to run your application from a subfolder, you will have to specify the `href_base` to your [bootstrap](#bootstrap). In `www/index.php`, call `setHrefBase()` with the relative location to the web root.

###Global handlers

Konstrukt comes with a default error handler and a class loader - `k_exceptions_error_handler` and `k_autoload`.

The error handler simply converts all errors into exceptions. It's recommended that you develop with this configuration, since it will force you to deal with errors, rather than ignoring them.

The class loader uses a simple convention to try and autoload undefined classes; Classnames are lowercased and underscores replaced with directory-separators. So a class named `foo_Bar` is expected to be defined in `foo/bar.php`. This convention is similar to  that of PEAR and Zend Framework, except that file/directory names are all lowercased. The reason for this is that classnames are case insensitive in PHP, while filenames aren't (At least not on unix systems).

###Naming convention

If you use the default autoloader (`k_autoload`), you should place your components in `/lib/components/` and name them accordingly. Eg. The following component should be placed in the file `/lib/components/foo/bar.php` :

..php
class components_foo_Bar extends k_Component {
  ...
}

###Bootstrap

The bootstrap is an object that is used to create the root component and dispatch it. It's really just a factory, that makes it simpler to configure the application.

To start your application, create a default bootstrap using the `k()` function. This will return an instance of `k_Bootstrap`. The bootstrap has a number of default settings which you can override. Finally, the bootstrap can invoke the application, by calling the method `run()`. Each setter-method returns `$this`, allowing you to write in a fluent style.

The most important setters on the bootstrap are:

`setComponentCreator`
: Sets the [componentcreator](#component-creation) to use.

`setCharsetStrategy`
: Set the [charsetstrategy](#encoding).

`setDebug`
: Enable/disable the in-browser [debug-bar](#debugging).

`setLog`
: Specifies a filename to log [debug information to](#debugging).

`setHrefBase`
: Sets the base href, if the application isn't [mounted at the web root](#static-content).


Debugging
---------

Konstrukt comes with some tools for making development easier. Since the dispatch process of components isn't as simple as plain php or a front controller setup, it can be useful to see the exact chain of events, to figure out which component is responsible for rendering the output. To this end, the dispatch is logged. You can get debug output in two ways; Through the debug-bar or through the logfile. For a production site, you can disable debugging to improve performance.

You can enable/disable debugging with the relevant methods of the bootstrap.

In addition to dispatch logging, you can also send arbitrary information to the logger. Each component has a protected method `debug()` which will dump the argument to the logger/debug-bar. It works much like `var_dump`.

###Logs

Dispatch and debug logging goes to the file `/log/development.log`. Additionally, the starterpack is configured to send php-errors to the file `/log/error.log`. While the development log is intended to use during development, the error log will usually be used on a production system. The log is configured by the `.htaccess` file in `www`. For a production site, you should edit this file to disable display of errors in the browser, and instead rely on the error log.

###Functional testing

Konstrukt comes with a testing harnish for testing components. Since all access to the HTTP layer is encapsulated in adapters, it is possible to test your application down to the HTTP level without actually having a running web server. This is useful for writing automated tests.
The testing harnish consists of an extension to the [SimpleTest](http://www.simpletest.org/) unit testing framework. The class `k_VirtualSimpleBrowser` acts as a drop-in replacement for [`SimpleBrowser`](http://simpletest.org/api/SimpleTest/WebTester/SimpleBrowser.html). To use it in a testcase, write your `WebTestCase` as normal, but override the method `createBrowser()` as this:

..php
class TestOfMyComponent extends WebTestCase {
  function createBrowser() {
    return new k_VirtualSimpleBrowser('components_MyComponent');
  }
  function test_request_root() {
    $this->assertTrue($this->get('/'));
    $this->assertResponse(200);
  }
}
