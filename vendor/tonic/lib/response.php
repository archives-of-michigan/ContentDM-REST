<?php
/*
Tonic: A simple RESTful Web publishing and development system
Copyright (C) 2007 Paul James <paul@peej.co.uk>

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/

// $Id: response.php 36 2008-01-15 22:39:21Z peejeh $

/**
 * Models the outgoing HTTP response from the server.
 * @package Tonic/Lib
 * @version $Revision: 36 $
 */
class Response
{
	
	/**
	 * The HTTP status code
	 */
	var $statusCode;
	
	/**
	 * HTTP response headers generated by the resource
	 * @var str[]
	 */
	var $headers;
	
	/**
	 * HTTP response body
	 * @var str
	 */
	var $body;
	
	/**
	 * The resource that generated this response
	 * @var Resource
	 */
	var $resource;
	
	var $messages = array(
		200 => 'OK',
		201 => 'Created',
		204 => 'No Content',
		301 => 'Moved Permanently',
		302 => 'Found',
		303 => 'See Other',
		304 => 'Not Modified',
		307 => 'Temporary Redirect',
		400 => 'Bad Request',
		401 => 'Unauthorized',
		403 => 'Forbidden',
		404 => 'Not Found',
		405 => 'Method Not Allowed',
		406 => 'Not Acceptable',
		410 => 'Gone',
		411 => 'Length Required',
		412 => 'Precondition Failed',
		415 => 'Unsupported Media Type',
		500 => 'Internal Server Error'
	);
	
	/**
	 * @param int statusCode
	 * @param str body
	 * @param str[] headers
	 */
	function response($statusCode = 200, $body = NULL, $headers = array())
	{
		$this->statusCode = $statusCode;
		$this->headers = $headers;
		$this->body = $body;
	}
	
	/**
	 * Set the default response headers. The response headers set are
	 * <ul>
	 * <li>Tonic advert header</li>
	 * <li>Etag header</li>
	 * <li>Last modified header</li>
	 * <li>Cache control header</li>
	 * <li>Content encoding header</li>
	 * <ul>
	 * @param Resource resource
	 * @param Request request
	 */
	function setDefaultHeaders(&$resource, &$request)
	{
		$this->headers['X-Powered-By'] = 'Tonic';
		if (substr($this->statusCode, 0, 1) == '2') { // only if we're sending a positive reply
			$mimetype = $resource->mimetype;
			if (isset($resource->_resource)) { // we're got a sub-resource that is the real resource
				$resource =& $resource->_resource;
			}
			if (isset($resource->cacheControl) && $resource->cacheControl == 0) {
				$this->headers['Cache-Control'] = 'max-age=0, must-revalidate';
			} else {
				if ($etag = $resource->entityTag()) {
					$this->headers['Etag'] = '"'.$etag.'"';
				}
				if ($resource->modified) {
					$this->headers['Last-Modified'] = date('r', $resource->modified);
				} else {
					$this->headers['Last-Modified'] = date('r', time());
				}
				if (isset($resource->cacheControl)) {
					$this->headers['Cache-Control'] = 'max-age='.$resource->cacheControl.', must-revalidate';
				} else {
					$this->headers['Cache-Control'] = 'max-age=86400, must-revalidate';
				}
			}
			if ($request->encoding && $this->body) {
				$this->headers['Content-Type'] = $mimetype.'; charset=UTF-8';
				$this->_doContentEncoding($request->encoding);
			}
			$this->headers['Content-Length'] = strlen($this->body);
		}
	}
	
	/**
	 * Add the extra headers in the given response object to this response
	 * @param Response response
	 */
	function addExtraHeaders(&$response)
	{
		foreach ($response->headers as $headerName => $value) {
			if (!isset($this->headers[$headerName])) {
				$this->headers[$headerName] = $value;
			}
		}
		$this->statusCode = $response->statusCode;
	}
	
	/**
	 * Add content encoding headers and encode the response body
	 * @param str[] encodings The acceptable encodings
	 */
	function _doContentEncoding($encodings)
	{
		if (ini_get('zlib.output_compression') == 0) { // do nothing if PHP will do the compression for us
			foreach ($encodings as $encoding) {
				switch($encoding) {
				case 'gzip':
					$this->headers['Content-Encoding'] = 'gzip';
					$this->body = gzencode($this->body);
					return;
				case 'deflate':
					$this->headers['Content-Encoding'] = 'deflate';
					$this->body = gzdeflate($this->body);
					return;
				case 'compress':
					$this->headers['Content-Encoding'] = 'compress';
					$this->body = gzcompress($this->body);
					return;
				case 'identity':
					return;
				}
			}
		}
	}
	
	/**
	 * Set up the HTTP Basic auth headers
	 * @param str[] config
	 * @param Resource resource
	 */
	function sendBasicAuthHeader(&$config, &$resource)
	{
		$this->headers['WWW-Authenticate'] = 'Basic realm="'.$resource->getRealm($config['realm']).'"';
	}
	
	/**
	 * Set up the HTTP Digest auth headers
	 * @param str[] config
	 * @param Resource resource
	 */
	function sendDigestAuthHeader(&$config, &$resource)
	{
		if (!$config['clientAddress']) {
			$config['clientAddress'] = $_SERVER['REMOTE_ADDR'];
		}
		$this->headers['WWW-Authenticate'] = 'Digest '.
			'realm="'.$resource->getRealm($config['realm']).'", '.
			'domain="'.$resource->url.'", '.
			'qop=auth, '.
			'algorithm=MD5, '.
			'nonce="'.$resource->getNonce($config['privateKey'], $config['life'], $config['clientAddress']).'", '.
			'opaque="'.md5($config['opaque']).'"';
	}
	
	/**
	 * Set up the HTTP Cookie auth headers
	 * @param str[] config
	 * @param Resource resource
	 * @param str username
	 */
	function sendAuthCookie(&$config, &$resource, $username)
	{
		$hash = md5($username.$resource->getNonce(
			$config['privateKey'],
			$config['life'],
			$config['clientAddress']
		));
		$this->headers['Set-Cookie'] = 'Tonic='.$username.':'.$hash.'; path=/; expires='.date('l, d-M-y H:i:s T', time() + $config['life']);
	}
	
	function success()
	{
		return substr($this->statusCode, 0, 1) == '2';
	}
	
	function redirection()
	{
		return substr($this->statusCode, 0, 1) == '3';
	}
	
	function error()
	{
		return substr($this->statusCode, 0, 1) == '4' || substr($this->statusCode, 0, 1) == '5';
	}
	
	/**
	 * Get the status message for this responses status code
	 * @return str
	 */
	function _statusMessage()
	{
		return isset($this->messages[$this->statusCode])?$this->messages[$this->statusCode]:'Unknown';
	}
	
	/**
	 * Send the response to the client
	 * @param bool friendlyMimetypes
	 */
	function output($friendlyMimetypes = FALSE)
	{
		header('HTTP/1.0 '.$this->statusCode.' '.$this->_statusMessage());
		foreach ($this->headers as $header => $value) {
			if ($friendlyMimetypes && $header == 'Content-Type') {
				header($header.': text/plain; charset=UTF-8');
			} else {
				header($header.': '.$value);
			}
		}
		if ($this->body) {
			echo $this->body;
		}
	}
}

?>
